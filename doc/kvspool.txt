kvspool: a tool for data streams
================================
Troy D. Hanson <tdh@tkhanson.net>
v0.5, March 2012

kv-spool ("key-value" spool):: 
         a Linux-based C library, with Perl, Python and Java bindings, to stream data
         between programs, in the form of key-value dictionaries (a.k.a., hashes).
         The spool data is backed to disk, supports snapshot, rewind and replay,
         network replication, and has configurable, steady-state disk consumption.

kvspool's niche
---------------
Kvspool falls somewhere between the Unix pipe, a file-backed queue and a message-passing
library. Its "unit of data" is the *dictionary*. (Or so Python calls it). Perl calls it a
hash. It's a set of key-value pairs.

To use kvspool, two programs open the same spool (which is just a directory). The reader
gets dictionaries from the spool, blocking when it's caught up; the writer puts
dictionaries into the spool. Like this,

.Sneak peak
[options="header",cols="20m,20m",grid="cols"]
|===============================================================================
| Sample Perl writer                       |  Sample C reader
| use KVSpool;                             |  #include "kvspool.h"
| my $v = KVSpool->new("spool");           |  void *sp = kv_spoolreader_new("spool");
| my $h = {\'day\'=>\'Wed\',\'temp'=>37};  |  void *set = kv_set_new();
| $v->write($h);                           |  kv_spool_read(sp,set,1);
|===============================================================================

The reader and writer transfer data through the spool on the disk. Because the spooled
data goes into the disk, the reader and writer are decoupled. They don't have to run
at the same time. Or they can come and go. The writer puts another dictionary into the
spool every time it invokes the "write" operation, and the reader gets them sequentially
when it invokes the "read" operation. If the reader exits and restarts, it picks up where
it left off.

.ramdisk: shared memory I/O
*****************************************************************************
A ramdisk is a good place to put a busy spool if you don't need disk backing.
For convenience kvspool includes a `ramdisk` utility to make a tmpfs ramdisk: 

  ramdisk -c -s 2G /mnt/ramdisk

*****************************************************************************

Space management
~~~~~~~~~~~~~~~~
In a streaming data environment, the writer and reader can run for months on end.  Because
the spool backs the data to disk, space management is necessary: 'don't fill up the disk'.
When we make a spool directory, we tell kvspool what its maximum size should be:

  % mkdir spool
  % kvsp-init -s 1G spool

This tells kvspool to keep a maximum of 1 GB of data.  The spool directory enters "steady
state" at that point, staying around 1 GB in size- even if the reader then consumes it all.
(The data is kept around to reserve that disk space, and to support rewind.) 

Attrition
~~~~~~~~~
When the spool is full, and new data arrives, the writer deletes the oldest data to make
room for new. (The attrition is done in units that are about 10% of the total spool size).
A reader that runs all the time, or reads often enough to keep up with the writer, never
needs to miss any data. But, if the reader is offline long enough it 

Rewind and replay
~~~~~~~~~~~~~~~~~
The spool is a like a long reel-to-reel tape spliced together at the ends. Data remains in
the spool after it's been read, until the spool needs to reclaim the space. Kvspool takes
advantage of this by supporting "rewind":

  % kvsp-rewind spool

If you run this (while the reader is not running- then start it up), reading starts at
the beginning of the spool. This is also useful in conjunction with taking a "snapshot":

  % cp -r spool snapshot

A snapshot is nothing more than a copy of the spool. Now you can bring it back to a
development environment, rewind it, and use it as a consistent source of test data.

Fan-out & Network Replication
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A spool is designed for one writer and one reader. If you need multiple readers you can
tee out to multiple spools:

  % kvsp-tee -s spool copy1 copy2

You can also publish a spool over the network, like this:

  % kvsp-pub -d spool tcp://192.168.1.9:1110

Now, on the remote computers where you wish to subscribe to the spool, run:

  % kvsp-sub -d spool tcp://192.168.1.9:1110

Obviously, the IP address must be valid on the publisher side. The port is up to you. This
type of publish-subscribe does a "fan-out" (each subscriber gets a copy of the data). If
you use the `-s` switch, on both pub and sub, it changes so each subscriber gets only a
"1/n" share of the data. The latter mode is preferred for 1-1 network replication.

[TIP]
Use a daemon supervisor such as the author's http://troydhanson.github.com/pmtr/[pmtr
process monitor] or a sysvinit script to start up these commands at boot up and keep them
running in the background.

License
~~~~~~~
See the link:LICENSE[LICENSE] file. Kvspool is free and open source.

Resources & Help 
~~~~~~~~~~~~~~~~
News about software updates are posted to the author's blog: http://tkhanson.net/blog.
Contact the author directly at tdh@tkhanson.net if you have questions or other issues.

Getting kvspool
---------------
You can clone kvspool from github:

  % git clone git://github.com/troydhanson/kvspool.git

To build it:

  % cd kvspool
  % # if the 'configure' script does not yet exist, run ./bootstrap
  % ./configure
  % make
  % sudo make install

This builds and installs the C library and utilities, and if the prerequisite packages
are installed, it builds the Perl, Python and Java bindings, and ZeroMQ-based utilities.

While kvspool does not depend on other libraries, to build the Network Replication
utilities you'll need *ZeroMQ* (2.x or 3.x) and the *Jansson* library installed.

Examples & API
--------------

Write examples
~~~~~~~~~~~~~~
We show a simple example of using the spool in Perl, Python and C here. Any time the
"spool write" operation is invoked, the data is immediately copied out to the spool and
available to a reader.

.Perl
[source,perl]
  use KVSpool;
  my $h = {'day' => 'Wednesday', 'user' => 'Troy'};
  my $v = KVSpool->new("spool");
  $v->write($h);

.Python
[source,python]
  import kvpy
  d = {"day":"Wednesday","user":"Troy"}
  kvpy.kvpy_write("spool",d)

.C
[source,c]
  #include "kvspool.h"
  ...
  void *sp = kv_spoolwriter_new("spool");
  void *set = kv_set_new();
  kv_adds(set, "day", "Wednesday");
  kv_adds(set, "user", "Troy");
  kv_spool_write(sp,set);
  ...
  kv_set_free(set);
  kv_spoolwriter_free(sp);

Read examples
~~~~~~~~~~~~~
The reader blocks if no data is available (except in C where a non-blocking read is
available). If data is available immediately, or when it becomes available, a hash or
dictionary or C equivalent is returned.

.Perl
[source,perl]
  use KVSpool;
  my $v = KVSpool->new("spool");
  my $h = $v->read();

.Python
[source,python]
  import kvpy
  d = kvpy.kvpy_read("spool")

.C
[source,c]
  #include "kvspool.h"
  ...
  void *sp = kv_spoolreader_new("spool");
  void *set = kv_set_new();
  kv_spool_read(sp,set,1);
  ...
  kv_set_free(set);
  kv_spoolreader_free(sp);

API
~~~

C/C++
^^^^^^
Programs written against the kvspool API can be linked with -lkvspool. Since both reading
and writing to the spool in C requires a "dictionary" data structure, one is included.

Reader
++++++
[source,c]
  void *kv_spoolreader_new(const char *dir);
  int kv_spool_read(void*sp, void *set, int blocking);
  void kv_spoolreader_free(void*);

This is also a programmatic equal of the `kvsp-rewind` command which can be used when the
reader does not have the spool open:
[source,c]
  void sp_reset(const char *dir);

Writer
++++++
[source,c]
  void *kv_spoolwriter_new(const char *dir);
  int kv_spool_write(void*sp, void *set);
  void kv_spoolwriter_free(void*);

Dictionary 
^^^^^^^^^^
[source,c]
  void* kv_set_new(void);
  void kv_set_free(void*);
  void kv_set_clear(void*);
  void kv_set_dump(void *set,FILE *out);
  void kv_add(void*set, const char *key, int klen, const char *val, int vlen);
  #define kv_adds(set, key, val) kv_add(set,key,strlen(key),val,strlen(val))
  kv_t *kv_get(void*set, char *key);
  int kv_len(void*set);
  kv_t *kv_next(void*set,kv_t *kv);

[source,c]
  typedef struct {
    char *key;
    int klen;
    char *val;
    int vlen;
  } kv_t;

A C program can iterate through all the keys/values like:

[source,c]
  kv_t *kv = NULL;
  while ( (kv = kv_next(set, kv))) {
    printf("key is %s\n", kv->key);
    printf("value is %s\n", kv->val);
  }


Perl
~~~~
In Perl, to use the module and open a spool for reading or writing:

[source,perl]
  use KVSpool;
  my $v = KVSpool->new("spool"); 

Then to read:

[source,perl]
  my $h = $v->read(); # returns a hash reference

Similarly to write:

[source,perl]
  $v->write($h); # where h is a hash reference

Python
~~~~~~
As of the current version kvspool only has a procedural interface for Python. If d is a
dicionary then the API to write or read a frame is simply:

[source,python]
  import kvpy
  kvpy.kvpy_write("spool",d)
  d = kvpy.kvpy_read("spool")

Utilities
---------

.Basic utilities
[width="90%",cols="10m,50m",grid="none",options="header"]
|===============================================================================
|command     | example 
|kvsp-init   | kvsp-init -s 1G spool
|kvsp-status | kvsp-status spool
|kvsp-rewind | kvsp-rewind spool
|kvsp-tee    | kvsp-tee -s spool-in spool-copy1 spool-copy2
|===============================================================================

The `kvsp-init` command is used when a spool directory is first created, to set 
the maximum capacity of the spool. It accepts k/m/g/t suffixes. If `kvsp-init` is
run later, after the spool already exists and has data, it is resized.

Run `kvsp-status` to see what percentage of the spool has been consumed by a reader.

The `kvsp-rewind` command resets the reader position to the beginning (oldest frame) in the
spool. Use this command in order to "replay" the spooled data. Disconnect (terminate) any
readers before running this command.

Use `kvsp-tee` to support multiple readers from one input spool. First make a separate
spool directory for each reader (and use `kvsp-init` to set the capacity of each one);
then use `kvsp-tee` as the reader on the source spool. It maintains a continuous copy of
the spool to the multiple destination spools. This command needs to be left running to
maintain the tee.

.Network utilities
[width="90%",cols="10m,50m",grid="none",options="header"]
|===============================================================================
|command     | example 
|kvsp-pub    | kvsp-pub -d spool tcp://192.168.1.9:1110
|kvsp-sub    | kvsp-sub -d spool tcp://192.168.1.9:1110
|===============================================================================

The network utilities keep a local spool continuously replicated to a remote spool.
These require ZeroMQ and Jansson libraries on the system in order to be built.

The `kvsp-pub` and `kvsp-sub` utilities publish a source spool to a remote spool.
The publisher listens on the specified TCP port, and the subscribers connect to it. 
More than one subscriber may run simultaneously. (The `kvsp-pub` commands acts as the
reader to the local stream, while `kvsp-sub` acts as the writer on remote stream.) 

Giving the `-s` flag to both `kvsp-pub` and `kvsp-sub` changes the operation from
"pub-sub" to "push-pull" mode (in ZeroMQ nomenclature). In this special `-s` mode, the
`kvsp-sub` instances each receive a "1/n" share of the data rather than full take.  Also,
in regular mode a publisher to which no subscriber is connected will drop frames but in
the special mode, the publisher retains data until a subscriber connects. (The data
capacity is still limited by the value set in `kvsp-init`.)

.Other utilities
[width="90%",cols="10m,50m",grid="none",options="header"]
|===============================================================================
|command     | example 
|kvsp-spr    | kvsp-spr -B 0 spool
|kvsp-spw    | kvsp-spw -i 10 spool
|kvsp-mod    | kvsp-mod -k key -o spool2 spool
|kvsp-speed  | kvsp-speed 
|ramdisk     | ramdisk -c -s 1G /mnt/ramdisk
|===============================================================================

The `kvsp-spr` utility is used to manually read a spool and print its frames to the
screen. Normally it will block waiting for data once it reaches the end of the spool but
the `-B 0` (no-block) option tells it to stop reading if the end of the spool is reached. 

The `kvsp-spw` utility is used only for testing; it writes a frame of data to the spool
(or several frames if the `-i` option is used with a count); in the latter mode there is a
sleep (delay) between each frame, which can be adjusted using the `-d <seconds>` option.

The `kvsp-mod` command "obfuscates" selected values from a source spool to hash values
in the output spool (named with the `-o` option). For each key named with the `-k` flag,
its value in the output spool is replaced with a mathematical hash.  The hash numbers
preserve consistency (so the same input value produces the same output value) but the
value itself is a meaningless number.

A simple benchmark is performed by the `kvsp-speed` utility to measure read and write
performance.

The `ramdisk` utility creates, queries or unmounts a ramdisk (a Linux tmpfs filesystem).
In the form shown in the table above it creates a 1G ramdisk on the `/mnt/ramdisk` mount
point (this directory must already exist). A ramdisk created this way will appear in the
`/proc/mounts` listing. If a ramdisk already exists on that mount point, the command does
nothing.  In create (`-c`) mode, the `-d <dir>` option may be used one or more times to
specify (as absolute paths) directories to create within the ramdisk.  Using `ramdisk -u
/mnt/ramdisk` unmounts it.  The `-q` option queries a directory to see if its a ramdisk
and show its size.  The `ramdisk` utility is included with kvspool because it is often
convenient to locate a spool on a ramdisk for performance.


Notes
-----
Kvspool is a young library and has some rough edges and room for improvement.

* The Python API needs an OO wrapper (it only has a procedural one right now).
* The Java API needs documentation and unit tests.
* The C API has some deprecated functions to support binary values 
* It's only been tested with Ubuntu 10.04
* Autoconf detection for Perl, Python, Java should be improved
* Test suite is minimal, although kvspool has extensive production use
* Support multi-writer, multi-reader (see link:future.txt[future.txt])
* Replace segemented data files with one memory mapped, circular file
* Use JSON internally

// vim: set tw=90 wm=2 syntax=asciidoc: 

