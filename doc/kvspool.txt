kvspool: a tool for data streams
================================
Troy D. Hanson <tdh@tkhanson.net>
v0.5, February 2012

kvspool (a key-value spool):: 
         a Linux-based C library used to read and write to a data stream, which is
         comprised of discrete frames; with network replication, snapshot/replay,
         bounded disk consumption and using key-value sets as the streaming unit.

kvspool's niche
---------------
Kvspool falls somewhere between the Unix pipe, a file-backed queue and a message-passing
library. It's not quite any of them, yet resembles them all. It reflects a personal set
of design goals.

* the spool is used to "stream" (transmit) data frames from one program to another 
* the spool frames are each a "hash"- a set of key-value pairs (aka a dictionary)
* the spool writer never blocks, even if the reader is slow, absent, or crashes
* the spool is a disk- or ramdisk-resident buffer of a configurable size
* the spool reader gets frames from the writer via the file system only
* the spool reader can exit, restart, and "catch up" with the writer
* the spool reader blocks (waiting for new data) when it's caught up
* the spool reader eventually misses data if it's persistently offline or slow 
* the spool frames remain on disk til their space is reclaimed  
* the spool can be copied off to a "snapshot" at any time
* the spool supports rewind and replay 
* the spool can be sent over a network

Sneak peak
~~~~~~~~~~
Here's an example of writing from Perl and reading from C.

[options="header",grid="columns"]
|===============================================================================
| Perl writer example                 |  C reader example
| use KVSpool;                        |  #include "kvspool.h"
| my $v = KVSpool->new("spool");      |  void *sp = kv_spoolreader_new("spool");
| my $h = {'day'=>'Wed','temp'=>37};  |  void *set = kv_set_new();
| $v->write($h);                      |  kv_spool_read(sp,set,1);
|===============================================================================

Rewind and replay
~~~~~~~~~~~~~~~~~
Kvspool keeps the data frames, even after they've been read-- until space needs to be
reclaimed. So the spool is a like a long reel-to-reel tape spliced together at the ends.
There are several nice outcomes of this:

* You have a history, or a "rear-view window" of the stream from writer to reader
* Because you have this history of the stream, you can copy it off 
* You can take it back to a development or test environment 
* You can "rewind" and "replay" the spool for testing

Canned data
^^^^^^^^^^^
For developers, kvspool can be a convenient way to take "canned" data from a production
environment. Just copy the spool. Now the data is canned. The developer can now take it
on a laptop (where the writer is not even necessary), rewind it, and use it as input.

Platform
~~~~~~~~
Kvspool is written for Linux 2.6+, and has support for C, Perl, Python and Java.  While
the C library does not strictly depend on other libraries, it's recommended to have
*ZeroMQ* (2.x or 3.x) and the *Jansson* library installed, to build the additional
utilities for network replication of spools. 

License
~~~~~~~
See the link:LICENSE[LICENSE] file. Kvspool is free and open source.

Resources & Help 
~~~~~~~~~~~~~~~~
News about software updates are posted to the author's blog: http://tkhanson.net/blog.
Contact the author directly at tdh@tkhanson.net if you have questions or other issues.

kvspool
-------

History & Motivation
~~~~~~~~~~~~~~~~~~~~
Once upon a time, there was a a sensor. Like a typical sensor, this one produced an
endless series of measurements. These were fed into another process with a Unix pipe: 

  sensor | analyzer

Beatiful and concise, but ask:

* what happens if `sensor` produces data faster than `analyzer` can read it?
* What happens to `sensor` if `analyzer` crashes?

For production software, this use of the pipe is not very robust; `sensor` is put to sleep
if `analyzer` reads the pipe too slowly, and any bugs that crash `analyzer` necessarily
break the pipe- probably crashing `sensor` too.

The pipeline connecting `sensor` to `analyzer` could be replaced many ways: e.g. with a
message passing library or even a database.  But kvspool has a different goal: to minimize
impact on the application. Linking with sophisticated libraries (which likely use threads
and sockets) was an anti-goal. Instead kvspool only reads and writes to the file system.
It was important to have an event-driven reader that blocks when waiting for data so that
CPU is not wasted with polling. The use of the 'inotify' system calls made this possible.

What does it look like?
^^^^^^^^^^^^^^^^^^^^^^^
Kvspool is a C library and language bindings and a set of command-line utilities. The
utilities configure the spool capacity, rewind a spool, view its status, set up network
replication, and so on. The API used to read and write the spool is extremely simple:
it only involves getting or giving a dictionary (that is, a hash, or set of key-value
pairs), one at a time. Hence the name, kvspool. The keys and values are always strings. 

Under the hood
++++++++++++++
The kvspool library and language bindings do not create threads or open network sockets.
They only read and write to the file system. The spool itself is just a directory which
contains files containing the data, and a file storing the reader position. As new data
comes in, eventually the spool reaches its maximum configured size. At this point, old
data is deleted (by unlinking the oldest file in the spool). Data is kept spool (even
after it's been read) up to the maximum size of the spool, in order to:

1. "reserve" that space on the disk 
2. so we can copy and replay it 

The spool data is stored in segmented data files that are each about one-tenth of the
spool's maximum configured size. These segments are the unit of attrition. So if a spool
is configured to store 10GB of data it will grow to that size, then the oldest 1G gets
deleted to make room for new data, and the cycle continues.

Roadmap 
+++++++
Kvspool is a young library and has some rough edges and room for improvement.

* The Python API needs an OO wrapper (it only has a procedural one right now).
* The Java API needs documentation and unit tests.
* The C API has some deprecated functions to support binary values 
* It's only been tested with Ubuntu 10.04
* Autoconf detection for Perl, Python, Java should be improved
* Test suite is minimal, although kvspool has extensive production use
* Support multi-writer, multi-reader (see link:future.txt[future.txt])
* Replace segemented data files with one memory mapped, circular file
* Use JSON internally

Getting kvspool
---------------
You can clone kvspool from github:

  % git clone git://github.com/troydhanson/kvspool.git

To build it:

  % cd kvspool
  % # if the 'configure' script does not yet exist, run ./bootstrap
  % ./configure
  % make
  % sudo make install

This builds and installs the C library and utilities, and if the prerequisite packages
are installed, it builds the Perl, Python and Java bindings, and ZeroMQ-based utilities.

Basics
------

Create a spool
~~~~~~~~~~~~~~
A spool is a directory- or technically, it resides in a directory. To make a spool, make a
directory. You can name it anything:

  % mkdir spool

It is recommended that you set its capacity. You can use K,M,G,T as suffixes.

  % kvsp-size -s 1G spool

In practice it's often convenient to locate the spool directory on a ramdisk (`/dev/shm`
or one of your own creation- kvspool includes a utility to make them easily).

Write data to spool
~~~~~~~~~~~~~~~~~~~
We show a simple example of using the spool in Perl, Python and C here. Any time the
"spool write" operation is invoked, the data is immediately copied out to the spool and
available to a reader.

.Perl
[source,perl]
  use KVSpool;
  my $h = {'day' => 'Wednesday', 'user' => 'Troy'};
  my $v = KVSpool->new("spool");
  $v->write($h);

.Python
[source,python]
  import kvpy
  d = {"day":"Wednesday","user":"Troy"}
  kvpy.kvpy_write("spool",d)

.C
[source,c]
  #include "kvspool.h"
  ...
  void *sp = kv_spoolwriter_new("spool");
  void *set = kv_set_new();
  kv_adds(set, "day", "Wednesday");
  kv_adds(set, "user", "Troy");
  kv_spool_write(sp,set);
  ...
  kv_set_free(set);
  kv_spoolwriter_free(sp);

Read data from spool
~~~~~~~~~~~~~~~~~~~~
The reader blocks if no data is available (except in C where a non-blocking read is
available). If data is available immediately, or when it becomes available, a hash or
dictionary or C equivalent is returned.

.Perl
[source,perl]
  use KVSpool;
  my $v = KVSpool->new("spool");
  my $h = $v->read();

.Python
[source,python]
  import kvpy
  d = kvpy.kvpy_read("spool")

.C
[source,c]
  #include "kvspool.h"
  ...
  void *sp = kv_spoolreader_new("spool");
  void *set = kv_set_new();
  kv_spool_read(sp,set,1);
  ...
  kv_set_free(set);
  kv_spoolreader_free(sp);

API
---

C/C++
~~~~~
Programs written against the kvspool API can be linked with -lkvspool. Since both reading
and writing to the spool in C requires a "dictionary" data structure, one is included.

Reader API
^^^^^^^^^^
[source,c]
  void *kv_spoolreader_new(const char *dir);
  int kv_spool_read(void*sp, void *set, int blocking);
  void kv_spoolreader_free(void*);

This is also a programmatic equal of the `kvsp-rewind` command which can be used if the
reader does not have the spool open:
[source,c]
  void sp_reset(const char *dir);

Writer API
^^^^^^^^^^
[source,c]
  void *kv_spoolwriter_new(const char *dir);
  int kv_spool_write(void*sp, void *set);
  void kv_spoolwriter_free(void*);

Dictionary API
^^^^^^^^^^^^^^
[source,c]
  void* kv_set_new(void);
  void kv_set_free(void*);
  void kv_set_clear(void*);
  void kv_set_dump(void *set,FILE *out);
  void kv_add(void*set, const char *key, int klen, const char *val, int vlen);
  #define kv_adds(set, key, val) kv_add(set,key,strlen(key),val,strlen(val))
  kv_t *kv_get(void*set, char *key);
  int kv_len(void*set);
  kv_t *kv_next(void*set,kv_t *kv);

[source,c]
  typedef struct {
    char *key;
    int klen;
    char *val;
    int vlen;
    /* other internal fields not shown */
  } kv_t;

A C program can iterate through all the keys/values like:

[source,c]
  kv_t *kv = NULL;
  while ( (kv = kv_next(set, kv))) {
    printf("key is %s\n", kv->key);
    printf("value is %s\n", kv->val);
  }


Perl
~~~~
In Perl, to use the module and open a spool for reading or writing:

[source,perl]
  use KVSpool;
  my $v = KVSpool->new("spool"); 

Then to read:

[source,perl]
  my $h = $v->read(); # returns a hash reference

Similarly to write:

[source,perl]
  $v->write($h); # where h is a hash reference

Python
~~~~~~
As of the current version kvspool only has a procedural interface for Python. If d is a
dicionary then the API to write or read a frame is simply:

[source,python]
  import kvpy
  kvpy.kvpy_write("spool",d)
  d = kvpy.kvpy_read("spool")

Utilities
---------

.Basic utilities
[width="90%",cols="10m,50m",grid="none",options="header"]
|===============================================================================
|command     | example 
|kvsp-size   | kvsp-size -s 1G spool
|kvsp-status | kvsp-status spool
|kvsp-rewind  | kvsp-rewind spool
|kvsp-tee    | kvsp-tee -s spool-in spool-copy1 spool-copy2
|===============================================================================

The `kvsp-size` command is used when a spool directory is first created, to set 
the maximum capacity of the spool. It accepts k/m/b/t suffixes. If `kvsp-size` is
run later, after the spool already exists and has data, it is resized.

Run `kvsp-status` to see what percentage of the spool has been consumed by a reader.

The `kvsp-rewind` command resets the reader position to the beginning (oldest frame) in the
spool. Use this command in order to "replay" the spooled data. Disconnect (terminate) any
readers before running this command.

Use `kvsp-tee` to support multiple readers from one input spool. First make a separate
spool directory for each reader (and use `kvsp-size` to set the capacity of each one);
then use `kvsp-tee` as the reader on the source spool. It maintains a continuous copy of
the spool to the multiple destination spools. This command needs to be left running to
maintain the tee.

.Network utilities
[width="90%",cols="10m,50m",grid="none",options="header"]
|===============================================================================
|command     | example 
|kvsp-pub    | kvsp-pub -d spool tcp://192.168.1.9:1110
|kvsp-sub    | kvsp-sub -d spool tcp://192.168.1.9:1110
|===============================================================================

The network utilities keep a local spool continuously replicated to a remote spool.
These require ZeroMQ and Jansson libraries on the system in order to be built.

The `kvsp-pub` and `kvsp-sub` utilities publish a source spool to a remote spool.
The publisher listens on the specified TCP port, and the subscribers connect to it. 
More than one subscriber may run simultaneously. (The `kvsp-pub` commands acts as the
reader to the local stream, while `kvsp-sub` acts as the writer on remote stream.) 

Giving the `-s` flag to both `kvsp-pub` and `kvsp-sub` changes the operation from
"pub-sub" to "push-pull" mode (in ZeroMQ nomenclature). In this special `-s` mode, the
`kvsp-sub` instances each receive a "1/n" share of the data rather than full take.  Also,
in regular mode a publisher to which no subscriber is connected will drop frames but in
the special mode, the publisher retains data until a subscriber connects. (The data
retention capacity is still limited by the `kvsp-size`.)

.Other utilities
[width="90%",cols="10m,50m",grid="none",options="header"]
|===============================================================================
|command     | example 
|kvsp-spr    | kvsp-spr -B 0 spool
|kvsp-spw    | kvsp-spw -i 10 spool
|kvsp-mod    | kvsp-mod -k key -o spool2 spool
|kvsp-speed  | kvsp-speed 
|ramdisk     | ramdisk -c -s 1G /mnt/ramdisk
|===============================================================================

The `kvsp-spr` utility is used to manually read a spool and print its frames to the
screen. Normally it will block waiting for data once it reaches the end of the spool but
the `-B 0` (no-block) option tells it to stop reading if the end of the spool is reached. 

The `kvsp-spw` utility is used only for testing; it writes a frame of data to the spool
(or several frames if the `-i` option is used with a count); in the latter mode there is a
sleep (delay) between each frame, which can be adjusted using the `-d <seconds>` option.

The `kvsp-mod` command "obfuscates" selected values from a source spool to hash values
in the output spool (named with the `-o` option). For each key named with the `-k` flag,
its value in the output spool is replaced with a mathematical hash.  The hash numbers
preserve consistency (so the same input value produces the same output value) but the
value itself is a meaningless number.

A simple benchmark is performed by the `kvsp-speed` utility to measure read and write
performance.

The `ramdisk` utility creates, queries or unmounts a ramdisk (a Linux tmpfs filesystem).
In the form shown in the table above it creates a 1G ramdisk on the `/mnt/ramdisk` mount
point (this directory must already exist). A ramdisk created this way will appear in the
`/proc/mounts` listing. If a ramdisk already exists on that mount point, the command does
nothing.  In create (`-c`) mode, the `-d <dir>` option may be used one or more times to
specify (as absolute paths) directories to create within the ramdisk.  Using `ramdisk -u
/mnt/ramdisk` unmounts it.  The `-q` option queries a directory to see if its a ramdisk
and show its size.  The `ramdisk` utility is included with kvspool because it is often
convenient to locate a spool on a ramdisk for performance.


Good practices
--------------

Snapshot and replay
~~~~~~~~~~~~~~~~~~~
It's useful to copy off (snapshot) the spool from a live process for offline development.
To snapshot a spool, just copy it:

  cp -r spool snapshot

(To avoid the small chance of copying a partially-written frame, suspend the writer before
copying the spool). With the snapshot copied off, it can now be "replayed" as often as
needed to develop new versions of the software that reads it. 
  
  kvsp-rewind snapshot

Use a ramdisk
~~~~~~~~~~~~~
A ramdisk is a good place to store a spool if there's a lot of data going in and out, if
the data is dispensable in a power outage. For convenience kvspool includes a `ramdisk`
utility to make a tmpfs ramdisk of a given size, where you can make a spool directory.

  ramdisk -c -s 2G /var/ramdisk
  mkdir /var/ramdisk/spool

Use a daemon manager
~~~~~~~~~~~~~~~~~~~~
Processes that need to start at boot and run continuously in the background, such
`kvsp-sub` and `kvsp-pub`, should be run under service supervision such as the author's
http://troydhanson.github.com/pmtr/[pmtr process monitor], a sysvinit script or similar.

Non-spool remotes
~~~~~~~~~~~~~~~~~
Platforms without kvspool such as Windows can still send or receive frames to a kvspool.
The "spool side" uses `kvsp-pub` or `kvsp-sub` to publish or subscribe to the spool, while
the "non-spool side" uses a ZeroMQ "pub/sub" or "push/pull" socket to send JSON-formatted
objects containing the key-value set.  An example of receiving JSON over ZeroMQ in Perl is
included in `tests/json-client.pl`.

// vim: set tw=90 wm=2 syntax=asciidoc: 

